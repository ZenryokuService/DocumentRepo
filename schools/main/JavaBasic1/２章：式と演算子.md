# 式と演算子

## 演算子
| 番号| 演算子 | 意味 |
| --- | ----- | ---- |
| 1   | .(ドット) | メソッド、フィールドの呼び出し|
| 2 | new | クラスのインスタンスを作成するときに使用する|
| 3 | == | 左右の数値が等しいか判定する(TRUE / FALSEを返す)|
| 4 | != | 左右の数値が**等しくない**か判定する(TRUE / FALSEを返す)|
| 5 | & | ビット演算 AND ＝「～かつ～」のときTRUE、それ以外はFALSE」|
| 6 | \| | ビット演算 OR ＝「～または～」のときTRUE、両方ともFALSEの場合はFALSE |
| 7 | ? XX : YY | 三項演算子 ＝「論理演算 ? TRUEの時の値 : FALSEの時の値」：<br/>例　String res = 1 == 1 ? "TRUEの場合": "FALSEの場合";|

## 2.2 オペランド
### 2.2.1 リテラル
# リテラルとは
下のように「リテラル」というのは変数に代入する値のことです。
①のコードには、リテラルがありません。
②のコードには、リテラルがあります。
```
// ①データ型 変数名; ＝宣言
int number;

// ②データ型 変数名 = 値	; ＝初期化
int number = 12;

```

上のコードでは、「12」がリテラルであり、このリテラルはint型のリテラルで「12」です。
このほかに、文字列のリテラルで使用するのは、「"」です。宣言・初期化する場合は、下のように書きます。
```
// ①データ型 変数名; ＝宣言
int moji;

// ②データ型 変数名 = 値	; ＝初期化
int moji = "12";

```

よく使われるのは、上のようなリテラルです。まとめると以下のようになります。

```

// int型のリテラルは「1」「12」「39」などの整数
int seisu = 12;

//  double 型のリテラルは「1.0」「1.2」「3.9」などの少数
double shosu = 1.2;

// 指数表記：3.0 x 10の4乗＝30000.0「2e2(2の2乗)」「4e2(4の4乗)」「5e5(5の5乗)」
double sisu = 3e4;

// 文字型のリテラルは(1文字なので)「'a'」「'b'」「'G'」などの文字
char moji = 'a';

// 文字列型のリテラルは「"abc"」「"もじれる"」「"1234"」
String mojiretu = "abc";

```

## そのほかのリテラル(データ型)
| 種類 | 例 | 説明 |
| ----  | --- | ---- |
| 1文字| 'A' | 1つの文字を'(シングルクォーテーション)で囲む |
| Unicode(ユニコード)| '\u3012' | \u の後に4桁の16進数を指定すると1文字を表す|
|8進数|0377|先頭に「0」をつけると8進数として扱われる、「010」は10進数での8に相当する|
|16進数|0x377|0から9までの数字とAからFまでのアルファベットを使用して数を表現する、0x10=16|
|2進数|0b10|0と1の数を使用して数を表現する「10101010」で8ビット＝1倍と分のデータを表す|

```
char uni = '\u3012';

int hassinsu = 010;
int jurokusinsu = 0x10;
int nisinsu = 0b10;
```



### 2.2.2 エスケープシーケンス
バックスラッシュ「\」もしくは、「￥」円記号(半角)をつけた文字のことでメタ文字を「文字」として使いたいときに使用する。

＜例＞
```
// 「"」は文字列を加工形で表示するためにエスケープシーケンスを使用する
// ※「"」を文字列として使用したいときは「エスケープ」する
String moji = "Javaのはじめの\"J\"は1文字目";
```

### 2.3 評価のしくみ
下のような式があったとします。
「1 + 5 -3」この式をプログラムで書くと次のコードになります。
```
public static void main(String[] args) {
  // 上の計算式
  int answer = 1 + 5 - 3;
}
```

このようなときに、処理の順序、「1 + 5」と「5 - 1」の評価はどのように行われるか？

**左から順に評価していきます**

つまり、以下の順序です。
1. 1 + 5の計算結果を出す
2. 上の結果に」「-1」する

**==しかし掛け算は先に処理を行う**
つまり以下のような優先順位で評価します。
1. 「掛け算・割り算」→「足し算・引き算」の順序
2. 左から順に評価

#### まとめると
1. 「掛け算・割り算」→「足し算・引き算」の順序で評価
2. 「=」以外の演算子は、左から順に評価
3. 「=」は右から評価


##### 問題＋α
以下のコードの場合、どのような順序で評価されるでしょうか？
```
System.out.println("Hello World!");
```

実行順序として正しいものを、<A>～<B>の中から選びなさい
<A>
1. Systemクラスの公開フィールド変数out(PrintStreamクラス)を取得
2. フィールド変数out(PrintStreamクラス)のメソッドprintln()を評価(呼び出している)

<B>
1. メソッドprintln()を取得
2. フィールド変数out(PrintStreamクラス)のSystemを評価(呼び出している)

## 2.4 演算子
### 2.4.1 算術演算子
| 演算子 | 機能 | 優先順位 |
| ----- | ----- | ------- |
|  +    | 足し算 | 中     |
|  -    | 引き算 | 中     |
|  *    | 掛け算 | 高     |
|  /    | 割り算 | 高     |


## 2.5 型の変換
### 2.5.3 強制的な型変換(キャスト)
  「int型」を「double型」に変換するというような形のキャスト
＜具体例＞
  ```
int num = 10;
// 強制的な型変換
double dd = (doubble) num;

// 下のやり方はエラーになる
// int num1 = (int) "10";

// 型をメソッドを使用して変換している
String tmp = String.valueOf(num);

// Stringが票差化された(左に文字列が先にある)あとであれば
// intやdoubleも文字列として評価される(自動キャスト)
System.out.println("aaaa" + 10.1);
  ```

#### 異なる型同士の算術演算
返却値(左側の変数型)は、**大きいほうの型のデータ型が優先**される

## 2.6 命令実行の文
### 2.6.5 乱数を生み出して代入する命令
```
// 3を上限値として乱数を生成する
int r = new java.util.Random().nexInt(3);
```

上にあるような「java.XXX.XXX」のようなパッケージはJDKの中にあるライブラリに定義されています。
そして、それらAPI群の使い方に関しては[JavaDoc](https://docs.oracle.com/javase/jp/8/docs/api/overview-summary.html)に書かれています。
* [Random()](https://docs.oracle.com/javase/jp/8/docs/api/java/util/Random.html)
* [Math()](https://docs.oracle.com/javase/jp/8/docs/api/java/lang/Math.html)
* [Scanner()](https://docs.oracle.com/javase/jp/8/docs/api/java/util/Scanner.html)

## 2.7 まとめ
**命令の実行はメソッド呼び出しのこと**
