## イントロダクション
基本情報技術者試験の勉強を始めようと思いました。

[試験問題の切り抜き](https://zenryokuservice.com/#!/mondai)を切り替えて問題を解く事ができます。※イメージファイルなので切り抜きになります。

このページを作成したのも、試験対策の一つです。

## Javaで基本情報技術者の教科書を学ぶ
### 基数の単位
色々な記述がありましたが、パソコンは**2進数**で様々な処理を行います。

2進数は、2になると1桁繰り上がります。表にすると下のようになります。

|10進数|2進数|
| --- | ---- |
|0    | 0 |
|1    | 1 |
|2    | 10 |
|3    | 11 |
|4    | 100 |
|5    | 101 |
|6    | 110 |
|7    | 111 |
|8    | 1000 |
|9    | 1001 |
|10   | 1010 |

## データ量の単位
1. 2進数の1桁を1ビットと呼ぶ「101」は3ビット
2. 8ビット＝1バイト(byte)
3. 1000バイト(10の3乗)=1k(キロ)バイト
4. 1000000バイト(10の6乗)=1M(メガ)バイト

表にすると下のようになります。
|単位|10進数|2進数|
| --- | ---- | -- |
| k(キロ) | 10の3乗 | 2の10乗 |
| M(メガ) | 10の6乗 | 2の20乗 |
| G(ギガ) | 10の9乗 | 2の30乗 |
| T(テラ) | 10の12乗 | 2の40乗 |
| P(ペタ) | 10の15乗 | 2の50乗 |

## ２進数の変換
上記で記載したように、パソコンは２進数を基本にしてデータを扱いますが、実際のところは10進数とか、8進数などの表示も行います。

そこで、2進数 ⇔ 10進数、2進数 ⇔ 16進数などのように、変換しています。これは、簡単な計算で行うことができます。

具体的には、下のように行います。

## 10進数からr進数への変換
> 1. x を r で割った時の商 p とあまり q を求める
2. p が０ならば、計算終了、それ以外は p を x に置き換えて 1 を行う
3. 計算した結果を下から順に並べなおす

### 10進数から2進数への変換
11を2進数に変換する場合
> 1. 11を２で割る = 5 ... 1
2. 5を２で割る = 2 ... 1
3. 2を２で割る = 1 ... 0
4. 1を２で割る = 0 ... 1

計算した結果を下から順に並べなおす。

Javaプログラムの実行結果とコードを以下に示します。

```
public String toBinaryString(int num, int kisu) {
    int p = num / kisu;
    int q = num % kisu;
    StringBuilder build = new StringBuilder();
    while (p != 0) {
        p = num / kisu;
        q = num % kisu;
        System.out.println("商: " + p + " 余り: " + q);
        num = p;
        build.append(q);
    }
    return build.toString();
}
```

![toBinary1](./toBinary.png)

## 小数点以下の変換
同様に、10進数から2進数への変換で、小数点以下のケースを行います。
> 1. x を r で乗算した結果を整数部の i と i を除いた小数値 d に分ける。
2. d の値が0ならば終了、そうでなければ１から繰り返す。

**余談**、JavaAPIに小数点以下の2進数変換メソッドがあるかと思ったら見当たらなかった。
だいたい自分でコードを書いている記事だった。

そして、小数点は、割り切れない場合があるのでいつになっても2進数に変換できない場合がある

このような数値のことを循環小数と呼び、**2進数への変換ができない**。

Javaで実装した場合
```
public String toBinaryString(Double num) {
    int seisu = num.intValue();
    StringBuilder build = new StringBuilder();
    // 小数点第５位で切り捨て
    Double r = nextDouble(num, 2);
    build.append(r.intValue());
    while (r != 1.0 && r != 0.0) {
        r = nextDouble(r, 2);
        System.out.println("次の小数: " + r);
        build.append(r.intValue());
    }
    String bin = toBinaryString(String.valueOf(seisu));
    return bin + "." + build.toString();
}

public Double nextDouble(Double num, int kisu) {
    int i = num.intValue();
    double d = new BigDecimal(num - i).setScale(5, RoundingMode.DOWN).doubleValue();
    System.out.println("整数: " + i + " / 小数: " + d);
    return d * kisu;
}
```
![](./img/toBinaryUnderDecimalPoint.png)

## r進数を10進数に変換
これは、2進数の「１」担っている部分を塁上で計算する。

**2進数で「10」の場合**
|右からX番目|計算|計算結果の合計|
| -- | -- | -- |
| 1番目 | 0なので計算しない | 0 |
| 2番目 | 2 の 1 乘 | 2 |

合計は 2 となり、2進数「10」を10進数に変換すると「2」になる。

**2進数で「101」の場合**
|右からX番目|計算|計算結果の合計|
| -- | -- | -- |
| 1番目 | 2 の 0 乘 | 1 |
| 2番目 | 0なので計算しない | 0 |
| 3番目 | 2 の 2 乘 | 4 |

合計は 5 となり、2進数「101」を10進数に変換すると「5」になる。

**2進数で「1111」の場合**
|右からX番目|計算|計算結果の合計|
| -- | -- | -- |
| 1番目 | 2 の 0 乘 | 1 |
| 2番目 | 2 の 1 乘 | 2 |
| 3番目 | 2 の 2 乘 | 4 |
| 4番目 | 2 の 3 乘 | 8 |

合計は 15 となり、2進数「1111」を10進数に変換すると「15」になる。

## 数値表現
符号なしの値は使用しないので、無視します。

 byte型8ビットのデータならば、ビットの数が8つ、つまり、最大値が以下のようになります。
 ```
 //最大値は整数で127
byte maxByte = 1111111;
 ```
しかし、これを素直に計算すると、255になる。。。
これは、一番左のビット(2進数)の値を符号として見るためです。符号なしの場合は、255までの値になります。

C言語では「unsigned」修飾子で符号なしも使用できるようですが、Javaでは余り使用しませんので。。。

## 2進数から r 進数に変換
これに関しては、2進数⇔10進数を除きます。

### 2進数から8進数
＜例＞
2進数の値を３つずつ区切り、３つの数を8進数に計算する。各値は下から並べる。
1. <pre>0101110</pre>は10進数では「46」になります。
2. 上の数値を３つずつに区切ると下のようになります。
<pre>0 => 符号正の数を示す</pre><pre>101 => 5</pre><pre>110 = > 6</pre>
というわけで、「56」になります。

### 2進数から16進数
＜例＞
2進数の値を３つずつ区切り、4つの数を16進数に計算する。各値は下から並べる。
1. <pre>0101110</pre>は10進数では「46」になります。
2. 上の数値を３つずつに区切ると下のようになります。
<pre>0 => 符号正の数を示す</pre><pre>010 => 2</pre><pre>1110 = > E</pre>
というわけで、「2E」になります。

[こちらのサイトでも確認しました。](https://keisan.casio.jp/exec/system/1311553754)

他のケースは使用したことがないので、記載しません。。。

## 2進数の演算
そして計算は、なんのひねりもなく、そのまんま計算します。
[参考サイトはこちら](https://yttm-work.jp/computer_basics/computer_basics_0006.html)です。
＜足し算＞
![](http://zenryokuservice.com/wp/wp-content/uploads/2021/01/スクリーンショット-2021-01-05-17.56.13.png)

![](http://zenryokuservice.com/wp/wp-content/uploads/2021/01/スクリーンショット-2021-01-05-17.57.38.png)

＜ひき算＞
![](http://zenryokuservice.com/wp/wp-content/uploads/2021/01/スクリーンショット-2021-01-05-17.57.48.png)

![](http://zenryokuservice.com/wp/wp-content/uploads/2021/01/スクリーンショット-2021-01-05-17.58.08.png)
＜かけ算＞
![](http://zenryokuservice.com/wp/wp-content/uploads/2021/01/スクリーンショット-2021-01-05-17.58.19.png)

＜割算＞
![](http://zenryokuservice.com/wp/wp-content/uploads/2021/01/スクリーンショット-2021-01-05-17.58.42.png)

## コンピュータが行う場合
上記の2進数演算ですが、人間がやる方法になります。
基本情報試験では、こちらの問題が出るようです。

[こちらのサイトを参考](https://proengineer.internous.co.jp/content/columnfeature/6254)にしました。

### 補数を使った計算
補数とは。。。
> 「元の数」と「補数」を足した場合に桁上がりが発生する数のうち「最小」の数のことです。
そして、2進数では「１の補数」と「２の補数」があり、１０進数にも、「１０の補数」と、減基数の「９の補数」が存在します。８進数ならそれぞれ「８の補数」と「７の補数」です。

ｎ進数の補数表現には、以下のものがあるということのようです。
> ｎ進数の補数表現には、それぞれ「ｎの補数」と「（ｎー１）の補数」が存在するのです。このｎは「基数」であり、（ｎ－１）は「減基数」です。

まとめると
* ｎ進数の補数表現 => 「ｎの補数」と「（ｎー１）の補数」がある
* n = 「基数」
* n - 1 = 「減基数」

##### 具体的には
＜10進数において＞
> 「６」の補数は「４」 -> お互いに足したら桁が上がる最小の数

一方「９の補数」の場合、お互いに足しても桁が上がらない数の最大値は、１０のべき乗から１を引いた値になります。
> 「６」の補数は「３」 -> １０の補数より１少ない数

わかりやすかった。

> 例えば、次のような計算をしたいとします。
 "１１９５－１７１＝１０２４"
ところがこの引き算という概念が使えない場合、足し算で同じ計算を行う方法があります。それに活用できるのが１０の補数です。


＜8進数において＞
> 「６」の補数は「４」 -> お互いに足したら桁が上がる最小の数
